#!/usr/bin/env python3
"""
tv-probe — discover smart TVs on LAN, or probe Android/Google TV codecs via ADB.

Usage:
  tv-probe                    # ARP-based LAN probe for likely TVs
  tv-probe <query>           # LAN probe filtered by free-text query
  tv-probe 192.168.1.42      # direct ADB codec probe for known IP

Requires: adb   (brew install android-platform-tools)
Optional: nmap  (brew install nmap)  — used as port-scan fallback
"""

import argparse, ipaddress, json, re, socket, ssl, subprocess, sys, time
from concurrent.futures import ThreadPoolExecutor
from urllib.error import URLError
from urllib.request import Request, urlopen

# ── Known TV OUI prefixes (first 3 octets, lowercase) ────────────────────────
KNOWN_TV_OUI_PREFIXES = {
    "54:b8:02", "c4:70:0b", "e4:aa:5d", "28:ba:b5", "a8:4e:3f", "00:1b:fb",
    "9c:8c:d8", "b4:7c:9c", "f0:43:47", "30:d3:2d", "ec:f6:45", "28:2c:b2",
    "00:12:47", "a4:c4:94", "e4:40:e2", "cc:e8:ac", "3c:5a:b4", "f0:e7:7e",
    "f4:7b:5e", "34:14:5f", "00:7f:28", "00:1e:75", "00:24:83", "a0:f1:dc",
    "10:f9:6f", "04:b1:67", "bc:f5:ac", "00:13:a9", "00:1a:80", "ac:9b:0a",
    "fc:0f:e6", "00:1d:ba", "28:0d:fc", "cc:6d:a0", "04:55:c8", "28:76:cd",
    "e8:8d:28", "50:86:5b", "00:60:d9", "bc:8c:cd", "74:13:ea", "c0:25:e9",
    "d0:03:df", "00:04:4b", "04:4b:ed", "00:12:fb", "00:90:8f", "00:e0:00",
}

# MIME → friendly codec name
MIME_MAP = {
    "video/av01":           "AV1",
    "video/hevc":           "HEVC / H.265",
    "video/avc":            "H.264 / AVC",
    "video/x-vnd.on2.vp9": "VP9",
    "video/x-vnd.on2.vp8": "VP8",
    "video/mp4v-es":        "MPEG-4",
    "video/mpeg2":          "MPEG-2",
}

# Prefixes that identify hardware-accelerated decoders
HW_PREFIXES = (
    "omx.mtk.", "omx.qcom.", "omx.qti.", "omx.exynos.", "omx.hisi.",
    "omx.rk.", "omx.amlogic.", "omx.aml.", "omx.brcm.", "omx.intel.",
    "omx.nvidia.", "c2.mtk.", "c2.qti.", "c2.exynos.", "c2.hisi.",
    "c2.rk.", "c2.amlogic.", "c2.nvidia.", "c2.broadcom.",
)
SW_PREFIXES = ("c2.android.", "omx.google.", "omx.sw.", "omx.ffmpeg.")
LAN_PROBE_PORTS = (7000, 8008, 8009, 8443)


# ── helpers ───────────────────────────────────────────────────────────────────

def die(msg):
    print(f"\n  ✗  {msg}", file=sys.stderr)
    sys.exit(1)


def check_deps(require_adb=True):
    missing = []
    required = ["arp"] + (["adb"] if require_adb else [])
    for cmd in required:
        if subprocess.run(["which", cmd], capture_output=True).returncode != 0:
            missing.append(cmd)
    if missing:
        print("\n✗  Missing required tools:\n")
        hints = {
            "adb": "brew install android-platform-tools",
            "arp": "built into macOS — reinstall via: brew install iproute2mac",
        }
        for m in missing:
            print(f"   {m:6}  →  {hints.get(m, 'install manually')}")
        print()
        sys.exit(1)
    has_nmap = subprocess.run(["which", "nmap"], capture_output=True).returncode == 0
    return has_nmap


# ── network discovery ─────────────────────────────────────────────────────────

def arp_entries():
    """Return list of (ip, mac_prefix_3octets) from macOS arp -a."""
    out = subprocess.run(["arp", "-a"], capture_output=True, text=True).stdout
    entries = []
    for line in out.splitlines():
        m = re.search(r'\(([0-9.]+)\).*at ([0-9a-f:]{5,17})', line, re.I)
        if not m:
            continue
        ip  = m.group(1)
        mac = m.group(2).lower()
        # Normalize short octets: 5:72 → 05:72
        parts  = [p.zfill(2) for p in mac.split(":")]
        prefix = ":".join(parts[:3])
        entries.append((ip, prefix))
    return entries


def local_subnet():
    """Best-guess /24 subnet base from default route, e.g. '192.168.1'."""
    try:
        out = subprocess.run(
            ["route", "-n", "get", "default"],
            capture_output=True, text=True
        ).stdout
        m = re.search(r'gateway:\s+(\d+\.\d+\.\d+)', out)
        if m:
            return m.group(1)
    except Exception:
        pass
    return "192.168.1"


def host_port_open(ip, port, timeout=0.35):
    try:
        with socket.create_connection((ip, port), timeout=timeout):
            return True
    except Exception:
        return False


def scan_open_ports(ips):
    open_map = {ip: [] for ip in ips}

    def check(item):
        ip, port = item
        return ip, port, host_port_open(ip, port)

    tasks = [(ip, port) for ip in ips for port in LAN_PROBE_PORTS]
    with ThreadPoolExecutor(max_workers=128) as ex:
        for ip, port, is_open in ex.map(check, tasks):
            if is_open:
                open_map[ip].append(port)

    for ip in open_map:
        open_map[ip].sort()
    return open_map


def http_probe(ip, port, path="/", timeout=1.5):
    scheme = "https" if port in (443, 8443) else "http"
    url = f"{scheme}://{ip}:{port}{path}"
    req = Request(url, headers={"User-Agent": "tv-probe/1.0", "Connection": "close"})
    context = ssl._create_unverified_context() if scheme == "https" else None
    try:
        with urlopen(req, timeout=timeout, context=context) as resp:
            body = resp.read(2048).decode("utf-8", errors="ignore")
            headers = "\n".join(f"{k}: {v}" for k, v in resp.headers.items()).lower()
            return True, headers, body.lower()
    except Exception:
        return False, "", ""


def classify_device(ip, open_ports):
    score = 0
    reasons = []
    details = []
    cast_text = ""
    model = None

    # Chromecast / Google TV endpoint
    if 8008 in open_ports:
        ok, _, body = http_probe(ip, 8008, "/setup/eureka_info?params=name,model_name")
        if ok and ("eureka_info" in body or '"model_name"' in body or "chromecast" in body):
            score += 5
            reasons.append("Google Cast endpoint")
            try:
                payload = json.loads(body)
                cast_name = payload.get("name")
                cast_model = payload.get("model_name")
                if cast_name or cast_model:
                    details.append(
                        "cast: "
                        + (cast_name or "?")
                        + (" / " + cast_model if cast_model else "")
                    )
                    cast_text = f"{cast_name or ''} {cast_model or ''}".strip()
            except Exception:
                pass
            if not model:
                for key in ('"model_name"', '"name"'):
                    m = re.search(rf'{key}\s*:\s*"([^"]+)"', body, re.I)
                    if m:
                        model = m.group(1).strip()
                        break

    return {
        "ip": ip,
        "model": model or "?",
        "score": score,
        "ports": open_ports,
        "reasons": reasons,
        "details": details,
        "cast_text": cast_text,
    }


def arp_prefix_for_ip(ip):
    for e_ip, prefix in arp_entries():
        if e_ip == ip:
            return prefix
    return None


def probe_single_ip(ip):
    open_ports = [p for p in LAN_PROBE_PORTS if host_port_open(ip, p)]
    return classify_device(ip, open_ports)


def lan_probe(cast_filter=None):
    if cast_filter:
        print(f"\n  LAN probe: scanning ARP neighbors for cast query '{cast_filter}' ...")
    else:
        print("\n  LAN probe: scanning ARP neighbors for TV fingerprints ...")
    entries = arp_entries()
    if not entries:
        print("  No ARP neighbors found.")
        return 1

    base = local_subnet()
    candidates = []
    for ip, prefix in entries:
        try:
            addr = ipaddress.ip_address(ip)
        except ValueError:
            continue
        if not addr.is_private or addr.is_multicast:
            continue
        if not ip.startswith(f"{base}."):
            continue
        candidates.append((ip, prefix))

    # de-dupe while preserving order
    seen_ips = set()
    deduped = []
    for ip, prefix in candidates:
        if ip in seen_ips:
            continue
        seen_ips.add(ip)
        deduped.append((ip, prefix))

    if not deduped:
        print(f"  No private neighbors in {base}.0/24 found.")
        return 1

    print(f"  Probing {len(deduped)} hosts on common TV ports ...")
    ip_to_prefix = {ip: prefix for ip, prefix in deduped}
    open_map = scan_open_ports(list(ip_to_prefix.keys()))

    results = []
    for ip, prefix in deduped:
        open_ports = open_map.get(ip, [])
        if not open_ports:
            continue
        result = classify_device(ip, open_ports)
        if result["score"] > 0:
            results.append(result)

    if cast_filter:
        needle = cast_filter.lower()
        results = [r for r in results if needle in r.get("cast_text", "").lower()]

    if not results:
        if cast_filter:
            print(f"  No likely TV devices matched cast query '{cast_filter}'.")
        else:
            print("  No likely TV devices detected from current ARP set.")
        return 1

    results.sort(key=lambda x: (-x["score"], x["ip"]))
    print()
    print("  Likely TV devices:")
    print("  IP               Score  Open Ports                  Evidence")
    print("  -------------------------------------------------------------------------------------------")
    for r in results:
        ports = ",".join(str(p) for p in r["ports"]) if r["ports"] else "-"
        reason = "; ".join(r["reasons"][:2]) if r["reasons"] else "-"
        detail = "; ".join(r.get("details", [])[:1])
        evidence = f"{reason} | {detail}" if detail else reason
        print(f"  {r['ip']:<15}  {r['score']:<5}  {ports:<25}  {evidence}")

    print()
    print("  Tip: run `tv-probe <ip>` against a candidate with port 5555 open for codec details.")
    print()
    return 0


# ── ADB ───────────────────────────────────────────────────────────────────────

def adb(ip, args, timeout=20):
    cmd = ["adb", "-s", f"{ip}:5555"] + args
    try:
        r = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout)
        return r.stdout.strip()
    except subprocess.TimeoutExpired:
        return ""


def adb_connect(ip):
    r = subprocess.run(
        ["adb", "connect", f"{ip}:5555"],
        capture_output=True, text=True, timeout=10
    )
    out = r.stdout.lower() + r.stderr.lower()
    return "connected" in out or "already connected" in out


def device_info(ip):
    props = {
        "model":   "ro.product.model",
        "brand":   "ro.product.brand",
        "android": "ro.build.version.release",
        "sdk":     "ro.build.version.sdk",
        "chipset": "ro.board.platform",
        "hw":      "ro.hardware",
        "arch":    "ro.product.cpu.abi",
    }
    return {k: adb(ip, ["shell", "getprop", v]) or "?" for k, v in props.items()}


# ── codec parsing ─────────────────────────────────────────────────────────────

def hw_class(name):
    """True = hardware, False = software, None = unknown."""
    nl = name.lower()
    if any(nl.startswith(p) for p in HW_PREFIXES):
        return True
    if any(nl.startswith(p) for p in SW_PREFIXES):
        return False
    return None


def parse_codecs(ip):
    """
    Parse `dumpsys media.codec` → list of decoder dicts:
      {mime, name, hw(bool|None), max_res(str|None)}

    Handles two output formats:
      Android 12+  MediaCodec{c2.mtk.av1.decoder, video/av01, rank=0}
      Legacy       [codec name="c2.mtk.av1.decoder" type="video/av01"]
    """
    raw  = adb(ip, ["shell", "dumpsys", "media.codec"], timeout=25)
    seen = set()
    results = []

    def add(name, mime, max_res=None):
        key = (name.lower(), mime.lower())
        if key in seen:
            return
        if not mime.lower().startswith("video/"):
            return
        if "encoder" in name.lower():
            return
        seen.add(key)
        results.append({
            "mime":    mime.lower(),
            "name":    name,
            "hw":      hw_class(name),
            "max_res": max_res,
        })

    # Format 1: MediaCodec{name, mime, ...}
    for m in re.finditer(
        r'MediaCodec\{([^,\}]+),\s*(video/[^,\s\}]+)', raw, re.I
    ):
        add(m.group(1).strip(), m.group(2).strip())

    # Format 2: [codec name="..." type="video/..."]
    if not results:
        for m in re.finditer(
            r'codec[^"]*name="([^"]+)"[^/]*(?:type="(video/[^"]+)")?', raw, re.I
        ):
            name = m.group(1).strip()
            mime = (m.group(2) or "").strip()
            if not mime:
                # type may be on the next line — scan nearby
                pos   = m.end()
                chunk = raw[pos:pos+200]
                tm    = re.search(r'type[^"]*"(video/[^"]+)"', chunk, re.I)
                mime  = tm.group(1).strip() if tm else ""
            if mime:
                add(name, mime)

    # Try to enrich max_res from lines like:  size: 64x64-3840x2160
    for entry in results:
        short = entry["name"].lower().replace(".", r"\.")
        pat   = re.compile(rf'{short}.*?size[:\s]+\S+-(\d+x\d+)', re.I | re.S)
        m     = pat.search(raw[:8000])  # search first 8KB to avoid slow full scan
        if m:
            entry["max_res"] = m.group(1)

    return results


def best_per_mime(decoders):
    """Keep best decoder per MIME: prefer HW, then highest res."""
    best = {}
    for d in decoders:
        mime = d["mime"]
        ex   = best.get(mime)
        if not ex:
            best[mime] = d
        elif d["hw"] is True and ex["hw"] is not True:
            best[mime] = d
        elif d["max_res"] and not ex.get("max_res"):
            best[mime]["max_res"] = d["max_res"]
    return best


# ── output ────────────────────────────────────────────────────────────────────

def print_table(rows, headers):
    if not rows:
        return
    w0  = max(len(headers[0]), max(len(r[0]) for r in rows))
    w1  = max(len(headers[1]), max(len(r[1]) for r in rows))
    sep = "  " + "─" * (w0 + w1 + 4 + 52)
    print()
    print(f"  {headers[0]:{w0}}  {headers[1]:{w1}}  {headers[2]}")
    print(sep)
    for prop, val, note in rows:
        print(f"  {prop:{w0}}  {val:{w1}}  {note}")
    print(sep)


# ── main ─────────────────────────────────────────────────────────────────────

def main():
    ap = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    ap.add_argument("target", nargs="?",
                    help="IP for ADB probe, or brand filter for LAN scan (tcl, samsung...)")
    ap.add_argument("--list-brands", action="store_true",
                    help="List supported brand names")
    args = ap.parse_args()

    if args.list_brands:
        print("\nSupported brands:")
        for b in sorted(set(BRAND_ALIASES.values())):
            print(f"  {b}")
        print()
        sys.exit(0)

    # Default mode: LAN scan of ARP-discovered hosts
    if not args.target:
        check_deps(require_adb=False)
        sys.exit(lan_probe())

    target = args.target.strip().lower()

    # Brand string => LAN scan with brand filter
    if not re.match(r'^\d+\.\d+\.\d+\.\d+$', target):
        check_deps(require_adb=False)
        brand = BRAND_ALIASES.get(target, target)
        sys.exit(lan_probe(brand_filter=brand))

    # IP => ADB codec probe path
    check_deps(require_adb=True)
    print()

    # ── resolve IP ─────────────────────────────────────────────────────────
    if re.match(r'^\d+\.\d+\.\d+\.\d+$', target):
        ip = target
        print(f"  Using IP directly: {ip}")
    else:
        die("Internal error: target is not an IP address")

    # Show transparent non-ADB fingerprint evidence first
    fp = probe_single_ip(ip)
    fp_ports = ",".join(str(p) for p in fp["ports"]) if fp["ports"] else "-"
    fp_reason = "; ".join(fp["reasons"][:2]) if fp["reasons"] else "no TV markers"
    fp_detail = "; ".join(fp.get("details", [])[:1])
    print(f"  Fingerprint   →  ports [{fp_ports}]")
    if fp_detail:
        print(f"  Evidence      →  {fp_reason} | {fp_detail}")
    else:
        print(f"  Evidence      →  {fp_reason}")

    # ── ADB connect ────────────────────────────────────────────────────────
    print(f"\n  Connecting  →  {ip}:5555 ...")
    if not adb_connect(ip):
        print()
        print(f"  ✗  ADB connection failed to {ip}:5555\n")
        print("  Check:")
        print("    • Developer Options → USB debugging is ON")
        print("    • Network debugging / ADB over WiFi is ON")
        print("    • Accept the authorisation prompt that appeared on the TV screen")
        print(f"    • Manual test: adb connect {ip}:5555")
        print()
        sys.exit(1)

    # ── device info ────────────────────────────────────────────────────────
    print("  Gathering device info ...")
    info    = device_info(ip)
    brand_s = info["brand"].title()
    model   = f"{brand_s} {info['model']}".strip()
    android = f"Android {info['android']}  (API {info['sdk']})"
    chipset = info["chipset"] if info["chipset"] not in ("?", "") else info["hw"]
    arch    = info["arch"]

    bar = "─" * max(0, 54 - len(model) - len(ip))
    print()
    print(f"  ┌─ {model}  @  {ip}  {bar}┐")
    print(f"  │  {android}")
    print(f"  │  Chipset  {chipset}    Arch  {arch}")
    print(f"  └{'─' * 56}┘")

    # ── codec probe ────────────────────────────────────────────────────────
    print("\n  Probing codecs (may take a few seconds) ...")
    decoders = parse_codecs(ip)
    best     = best_per_mime(decoders)

    codec_rows = []
    priority_mimes = [
        "video/av01",
        "video/hevc",
        "video/avc",
        "video/x-vnd.on2.vp9",
        "video/x-vnd.on2.vp8",
        "video/mp4v-es",
        "video/mpeg2",
    ]
    for mime in priority_mimes:
        friendly = MIME_MAP.get(mime, mime)
        entry    = best.get(mime)
        if not entry:
            codec_rows.append((friendly, "✗ Not found", ""))
            continue

        hw = entry["hw"]
        if hw is True:
            hw_str = "✓ Hardware"
        elif hw is False:
            hw_str = "  Software"
        else:
            hw_str = "  Unknown"

        res  = entry["max_res"] or "?"
        name = re.sub(r'^(?:omx|c2)\.[^.]+\.', '', entry["name"], flags=re.I)

        if mime == "video/av01":
            if hw is True:
                note = f"HW decode confirmed · max {res} · {name}"
            elif hw is False:
                note = f"⚠ SW only — Jellyfin will transcode · {name}"
            else:
                note = f"Decoder found, HW status unknown · {name}"
        else:
            note = f"max {res} · {name}" if res != "?" else name

        codec_rows.append((friendly, hw_str, note))

    print_table(codec_rows, ("Codec", "Decode", "Details"))

    # ── audio passthrough (static — known Android TV / Google TV behaviour) ──
    audio_rows = [
        ("DD+ / EAC3",       "✓ Passthrough",    "Native on Android TV + Sonos"),
        ("Dolby Atmos",      "✓ Passthrough",    "DD+ Atmos / DDPA — object metadata preserved"),
        ("AC3",              "✓ Passthrough",    "Dolby Digital — native"),
        ("TrueHD / Atmos",   "✗ No passthrough", "Transcodes to AC3; Atmos object layer lost"),
        ("DTS-HD MA",        "✗ No passthrough", "Transcodes to AC3; lossless not delivered"),
        ("DTS:X",            "✗ No passthrough", "Object layer lost on transcode"),
        ("DTS core",         "⚠ Limited",        "Passthrough inconsistent; may transcode"),
        ("AAC",              "✓ Decode",         "Native decode; no transcode"),
        ("PCM / FLAC",       "✗ No passthrough", "Lossless — Jellyfin transcodes; Android TV cannot passthrough"),
    ]
    print()
    print("  Audio passthrough  (Android TV / Google TV — all devices)")
    print_table(audio_rows, ("Format", "Status", "Note"))

    print()


if __name__ == "__main__":
    main()
